#################################################################################
## Simulation of CDN CCC.
## (c) Llorenç Cerdà, 2016
#################################################################################
source("event-simulator.R")

##
## Introduction to R6 classes:
## https://cran.r-project.org/web/packages/R6/vignettes/Introduction.html
##
library(R6)
library(VGAM) # rtruncpareto

##
## truncated rlnorm
##
truncated.log.normal <- function(mean, std.dev, min, max) {
    repeat {
        r <- rlnorm(1, meanlog=mean, sdlog=std.dev)
        if((r >= min) && (r <= max)) break ;
    }
    r
}

##
## Internet one way delay model
## Lognormal: meanlog=2.8447, sdlog=0.0088
## mean: exp(meanlog+sdlog^2/2) = 17.19706 ms
## coefficient of variation: sqrt(exp(sdlog^2)-1) = 0.0088 ms
## @inproceedings{hernandez2007one,
##   title =	 {One-way delay measurement and characterization},
##   author =	 {Hernandez, Ana and Magana, Eduardo},
##   booktitle =	 {Networking and Services, 2007. ICNS. Third
##                   International Conference on},
##   pages =	 {114--114},
##   year =	 2007,
##   organization = {IEEE}
## }
meanlog <- 2.8447
sdlog <- 0.0088
get.owd <- function(n=1) {
    if(meanlog > 0) {
        rlnorm(n=n, meanlog=meanlog, sdlog=sdlog)*1e-3 # seconds
    } else {
        0.0
    }
}
set.owd.parameters <- function(mean, coef.var=0.0088) {
    v <- (mean*coef.var)^2
    if(mean > 0) {
        meanlog <<- log(mean/sqrt(1+v/mean^2))
        sdlog <<- sqrt(log(1+v/mean^2))
    } else {
        meanlog <<- 0
    }
}

##
## HTTP requests generator
## Model described in cdma2000 Evaluation Methodology, HTTP Model, page 59.
## http://www.3gpp2.org/public_html/specs/C.R1002-0_v1.0_041221.pdf
##
httpr <- function() {
    ## size of main object
    size <- truncated.log.normal(mean=8.35, std.dev=1.37, min=100, max=2e6)
    ## number of embedded objects
    num.emb <- round(rtruncpareto(1, lower=2, upper=55, shape=1.1))-2
    if(num.emb > 0) {
        size + sum(sapply(1:num.emb,
                          function(m)
                              truncated.log.normal(mean=6.17, std.dev=2.36, min=50, max=2e6)
                          ))
    } else {
        size
    }
}

##
## Mean of the RV generated by httpr
##
httpr.mean <- function() {
    mean.embedded.objects <- (1.1*2)/(1.1-1)*(1-(2/55)^(1.1-1))/(1-(2/55)^(1.1))-2
    10710 + 8140 * mean.embedded.objects
}

##
## send.message class
##
send.message <-
    R6Class("send.message",
            inherit = Event,
            portable = TRUE,
            cloneable = FALSE,
            private = list(
                destination=NULL,
                parameters=NULL
           ),
            public = list(
                initialize = function(delay, destination, parameters) {
                    if(delay>0) {
                        private$destination <- destination
                        private$parameters <- parameters
                        super$sched.event(time=delay)
                    } else {
                        destination(parameters)
                    }
                },
                handle.event = function() {
                    private$destination(private$parameters)
                }
            ))
                

##
## Arrival class
##
arrival <-
    R6Class("arrival",
            inherit = Event,
            portable = TRUE,
            cloneable = FALSE,
            private = list(
                arrivals.per.second=NA,
                notify.arrival=NULL,
                ## statistics
                total.arrivals=0,
                total.traffic=0
           ),
            public = list(
                initialize = function(arrivals.per.second,
                    first.arrival.time,
                    notify.arrival) {
                    private$arrivals.per.second <- arrivals.per.second
                    private$notify.arrival <- notify.arrival
                    private$total.arrivals <- 0
                    private$total.traffic <- 0
                    super$sched.event(time=first.arrival.time+rexp(1, private$arrivals.per.second))
                },
                handle.event = function() {
                    http.request.size <- httpr()
                    private$notify.arrival(http.request.size)
                    private$total.arrivals <- private$total.arrivals+1
                    private$total.traffic <- private$total.traffic + http.request.size
                    ## schedule next arrival
                    super$sched.event(time=rexp(1, private$arrivals.per.second))
                },
                print = function() {
                    message("Total number of arrivals: ",
                            private$total.arrivals)
                    message(sprintf("Mean traffic [MBps]: %.2f",
                                    (private$total.traffic*1e-6)/simu.currtime))
                    message(sprintf("Mean arrival size [kB]: %.2f",
                                    (private$total.traffic*1e-3)/
                                        private$total.arrivals))
                }
            ))
## end of arrival class

##
## ZoneRR class
##
ZoneRR <-
    R6Class("ZoneRR",
            portable = TRUE,
            cloneable = FALSE,
            private = list(
                sla.r=NA,    ## Bw SLA [Bps]
                Rweight=NA,
                cdn=NULL,
                bgd=NULL,
                choose.proxy.type=NULL, # cost, roundrobin
                roundrobin.last.proxy=NULL,
                number.of.proxies=NULL,
                ##
                ## cost function
                ##
                cost = function() {
                    (self$Qreq+1)*self$Penalty + private$Rweight * self$Rqueue 
                },
                cost2 = function() {
                    self$Qreq + private$Rweight * self$Rqueue 
                },
                roundrobin = function() {
                    private$roundrobin.last.proxy <-
                        (private$roundrobin.last.proxy %% private$number.of.proxies) + 1
                }
            ),
            public = list(
                Qreq = NULL,   ## ongoing requests queue
                Rqueue = NULL, ## 1/Bw SLA queue
                Penalty = NULL, ## 1/Bw reported
                proxies = NULL,## proxies list
                fileConn = NULL,
                initialize = function(N,
                    proxy.access.bw, # Proxy Bw vector [Bps]
                    sla.bw, # Connection Bw SLA [Mbps]
                    cdn.load, # cdn load
                    bgd.load, # background load
                    Rweight,  # gamma in equation (3)
                    zrr.update.time, # ZRR update time
                    choose.proxy.type='cost', # proxy selection type: cost, roundrobin
                    max.queue.len=max.queue.len, # max requets allowed by a proxy
                    fname=NULL  # trace file name
                                      ){
                    ##
                    stopifnot(N>0)
                    stopifnot(length(proxy.access.bw)==N)
                    simu.init.event.sim()
                    private$sla.r <- 8e-6/sla.bw # Convert sla.bw from Mbps to Bps
                    private$Rweight <- Rweight
                    self$Rqueue <- vector(mode = "numeric", len=N)
                    self$Qreq <-   vector(mode = "integer", len=N)
                    self$Penalty <- vector(mode = "numeric", len=N)
                    private$choose.proxy.type <- choose.proxy.type
                    private$roundrobin.last.proxy <- 0
                    private$number.of.proxies <- N
                    if(!is.null(fname)) {
                        fname <- paste0(fname, '.gz')
                        message("Trace file: ", fname)
                        self$fileConn <- gzfile(fname, "w")
                        ## write trace header
                        cat("proxy type throughput QLen\n", file=self$fileConn)
                    }
                    for(n in 1:N) {
                        self$proxies[[n]] <-
                            Proxy$new(id=n, zrr=self, access.bw=proxy.access.bw[n],
                                      zrr.update.time=zrr.update.time, max.queue.len=max.queue.len) ;
                    }
                    ## schedule 1st HTTP request cdn.request.
                    cdn.aps <- cdn.load*sum(proxy.access.bw)/httpr.mean()
                    bgd.aps <- bgd.load*sum(proxy.access.bw)/httpr.mean()
                    message("cdn.requests.per.second: ", sprintf("%.2f", cdn.aps))
                    message("bgd.requests.per.second: ", sprintf("%.2f", bgd.aps))
                    private$cdn <- arrival$new(arrivals.per.second=cdn.aps,
                                               first.arrival.time=0,
                                               notify.arrival=self$cdn.request)
                    if(bgd.load > 0) {
                        private$bgd <- arrival$new(arrivals.per.second=bgd.aps,
                                                   first.arrival.time=N*zrr.update.time,
                                                   notify.arrival=self$bgd.request)
                    }
                },
                ##
                close.trace = function() {
                    if(!is.null(self$fileConn)) {
                        close(self$fileConn)
                    }
                },
                ##
                ## Proxy update
                ##
                update = function(par) {
                    if(debug.events) {
                        message(sprintf("%.2f proxy.arr%d e=%d r=%.2g v=%.2f",
                                        simu.currtime, par$id, par$e, par$r, par$v))
                    }
                    self$Rqueue[par$id] <- max(self$Rqueue[par$id]+par$r-private$sla.r, 0)
                    self$Penalty[par$id] <- par$r
                    self$Qreq[par$id] <- self$Qreq[par$id] - par$e
                },
                ##
                ## cdn.request handler
                ##
                cdn.request = function(http.request.size) {
                    choose.proxy <-
                        switch(private$choose.proxy.type,
                               cost = which.min(private$cost()),
                               cost2 = which.min(private$cost2()),
                               roundrobin = private$roundrobin(),
                               stop("choose.proxy.type?"))
                    if(debug.events) {
                        message(sprintf("%.2f cdn.send %d", simu.currtime, choose.proxy))
                    }
                    send.message$new(delay=get.owd(),
                                 destination=self$proxies[[choose.proxy]]$cdn.arrival,
                                 parameters=http.request.size)
                    self$Qreq[choose.proxy] <- self$Qreq[choose.proxy] + 1
                },
                ##
                ## bgd.request event handler
                ##
                bgd.request = function(http.request.size) {
                    choose.proxy <- sample(1:length(self$proxies), size=1)
                    if(debug.events) {
                        message(sprintf("%.2f bgd.send %d", simu.currtime, choose.proxy))
                    }
                    send.message$new(delay=get.owd(),
                                 destination=self$proxies[[choose.proxy]]$bgd.arrival,
                                 parameters=http.request.size)
                },
                print = function() {
                    message(sprintf("Aggregated proxy capacity [MBps]: %.2f",
                                    sum(sapply(1:length(self$proxies), function(n)
                                        self$proxies[[n]]$get.access.bw()))*1e-6))
                    message("CDN traffic")
                    private$cdn$print()
                    message("BACKGROUND traffic")
                    if(!is.null(private$bgd)) {
                        private$bgd$print()
                    }
                    self$proxies[[1]]$print.header()
                    for(p in self$proxies) { p$print() }
                }
            ))
## end of ZoneRR class

##
## queue class
##
queue <- 
    R6Class("queue",
            portable = TRUE,
            cloneable = FALSE,
            ##
            private = list(
                ##
                ## binary search of insertion point in the queue (descending order)
                ## 
                binsearch = function(hi, y) {
                    lo <- 1
                    while(lo+1 < hi) {
                        mid <- (lo+hi) %/% 2
                        if(y == self$req[mid]) return(mid)
                        if(y > self$req[mid]) hi <- mid else lo <- mid
                    }
                    if(y >= self$req[lo]) return(lo)
                    if(y > self$req[hi]) return(hi)
                    return(hi+1)
                }
            ),
            public = list(
                max.len=NA, # max queue length
                time=NULL,  # requests arrival times
                bytes=NULL, # requests (total number of bytes to be transmitted)
                req=NULL,   # requests (bytes yet to be transmitted)
                len=NA,     # queue length
                ## statistics
                lost=NA, # lost requests
                arrivals=NA, # number of arrivals
                traffic.volume=NA, # traffic volume
                departures=NA,
                ##
                initialize = function(
                    max.len=1000) { # Maximum number of ongoing requests.
                    self$max.len <- max.len
                    self$bytes <- vector(mode='double', length=max.len) # number of bytes
                    self$req   <- vector(mode='double', length=max.len) # number of bytes
                    self$time  <- vector(mode='double', length=max.len) # requests arrival times
                    self$len <- 0
                    self$lost <- 0
                    self$arrivals <- 0
                    self$traffic.volume <- 0
                    self$departures <- 0
                },
                print = function() {
                    if(self$len > 0) {
                        message(paste0(sep='', format(self$req[1:self$len], digits=2, nsmall=1), collapse=' '))
                    } else {
                        message('empty')
                    }
                },
                add = function(size) {
                    self$arrivals <- self$arrivals+1
                    if(self$len == 0) { # the queue is empty
                        self$bytes[1] <- size
                        self$req[1]   <- size
                        self$time[1]  <- simu.currtime
                        self$len <- 1
                    } else {
                        if(self$len == self$max.len) {
                            self$lost <- self$lost + 1
                            return(FALSE)
                        } else {
                            if(size >= self$req[1]) { # 1st position
                                self$bytes[2:(self$len+1)] <- self$bytes[1:self$len]
                                self$req[2:(self$len+1)]   <- self$req[1:self$len]
                                self$time[2:(self$len+1)]  <- self$time[1:self$len]                                
                                self$bytes[1] <- size
                                self$req[1]   <- size
                                self$time[1]  <- simu.currtime
                            } else if(size <= self$req[self$len]) { # last position
                                self$bytes[self$len+1] <- size
                                self$req[self$len+1]   <- size
                                self$time[self$len+1]  <- simu.currtime
                            } else {
                                inspt <- private$binsearch(self$len, size)
                                self$bytes[1:(self$len+1)] <-
                                    c(self$bytes[1:(inspt-1)],
                                      size,
                                      self$bytes[inspt:self$len])
                                self$req[1:(self$len+1)] <-
                                    c(self$req[1:(inspt-1)],
                                      size,
                                      self$req[inspt:self$len])
                                self$time[1:(self$len+1)] <-
                                    c(self$time[1:(inspt-1)],
                                      simu.currtime,
                                      self$time[inspt:self$len])
                            }
                            self$len <- self$len + 1
                        }
                    }
                    return(TRUE)
                },
                del = function() {
                    self$len <- self$len-1
                    self$departures <- self$departures+1
                },
                update.bytes.pending.to.tx = function(size) {
                    self$req[1:self$len] <- self$req[1:self$len] - size
                }
            ))
## end of queue class

##
## Proxy class
##
Proxy <-
    R6Class("Proxy",
            inherit = Event,
            portable = TRUE,
            cloneable = FALSE,
            ##
            private = list(
                id=NA,        # Proxy id
                zrr=NULL,     # field pointing to ZoneRR
                zrr.update.time=1,# ZRR update time
                access.bw=NA, # available Bw, MBps (Bytes per second)
                dispatched=NA, # Number of CDN dispatched req. during the current slot.
                dispatched.lost=NA, # Number of CDN lost req. during the current slot.
                sum.successful.dispatched.bw=NA,   # mean Bw of CDN dispatched requests.
                cdn.traffic.volume=NA, # Bytes of CDN traffic dispatched during the current slot.
                updates=NA,   # number of updates
                queue.last.update.time=NA, # last time the queues where updated
                ##
                queue.cdn=NULL, # queue of CDN requests (bytes yet to be transmitted)
                queue.bgd=NULL, # queue of background requests (bytes yet to be transmitted)
                ## statistics
                cdn.throughput.sum=NA,
                bgd.throughput.sum=NA,
                ##
                ## Check wheter the head of the queue finished Tx before current time.
                ## 
                number.of.tx.bytes = function(tlen) {
                    (private$access.bw/tlen) *
                        (simu.currtime-private$queue.last.update.time) ; 
                },
                ##
                ##
                ##
                cdn.departure = function(size) {
                    private$queue.last.update.time <- private$queue.last.update.time +
                        (size*(private$queue.cdn$len+private$queue.bgd$len))/private$access.bw
                    throughput <- private$queue.cdn$bytes[private$queue.cdn$len]/
                        (private$queue.last.update.time-private$queue.cdn$time[private$queue.cdn$len])
                    private$cdn.throughput.sum <- private$cdn.throughput.sum + throughput
                    private$dispatched <- private$dispatched+1
                    private$sum.successful.dispatched.bw <- private$sum.successful.dispatched.bw+throughput
                    private$queue.cdn$del()
                    if(!is.null(private$zrr$fileConn)) {
                        cat(private$id, "cdn", throughput, private$queue.cdn$len+private$queue.bgd$len,
                            "\n", file=private$zrr$fileConn)
                    }
                },
                bgd.departure = function(size) {
                    private$queue.last.update.time <- private$queue.last.update.time +
                        (size*(private$queue.cdn$len+private$queue.bgd$len))/private$access.bw
                    throughput <- private$queue.bgd$bytes[private$queue.bgd$len]/
                        (private$queue.last.update.time-private$queue.bgd$time[private$queue.bgd$len])
                    stopifnot(throughput > 0)
                    private$bgd.throughput.sum <- private$bgd.throughput.sum + throughput                        
                    private$queue.bgd$del()
                    if(!is.null(private$zrr$fileConn)) {
                        cat(private$id, "bgd", throughput, private$queue.cdn$len+private$queue.bgd$len,
                            "\n", file=private$zrr$fileConn)
                    }
                },
                update.queue.req = function() {
                    if(private$queue.cdn$len > 0) {
                        if(private$queue.bgd$len > 0) {
                            tx <- private$number.of.tx.bytes(private$queue.cdn$len + private$queue.bgd$len)
                            if(private$queue.cdn$req[private$queue.cdn$len] <=
                               private$queue.bgd$req[private$queue.bgd$len]) {
                                size <- private$queue.cdn$req[private$queue.cdn$len]
                                if(tx >= size) {
                                    private$cdn.departure(size)
                                    if(private$queue.cdn$len > 0) {
                                        private$queue.cdn$update.bytes.pending.to.tx(size)
                                    }
                                    private$queue.bgd$update.bytes.pending.to.tx(size)
                                    return(TRUE)
                                }
                            } else {
                                size <- private$queue.bgd$req[private$queue.bgd$len]
                                if(tx >= size) {
                                    private$bgd.departure(size)
                                    if(private$queue.bgd$len > 0) {
                                        private$queue.bgd$update.bytes.pending.to.tx(size)
                                    }
                                    private$queue.cdn$update.bytes.pending.to.tx(size)
                                    return(TRUE)
                                }
                            }
                            private$queue.cdn$update.bytes.pending.to.tx(tx)
                            private$queue.bgd$update.bytes.pending.to.tx(tx)
                        } else { # bgd queue is empty
                            tx <- private$number.of.tx.bytes(private$queue.cdn$len)                            
                            size <- private$queue.cdn$req[private$queue.cdn$len]
                            if(tx >= size) {
                                private$cdn.departure(size)
                                if(private$queue.cdn$len > 0) {
                                    private$queue.cdn$update.bytes.pending.to.tx(size)
                                }
                                return(TRUE)
                            }
                            private$queue.cdn$update.bytes.pending.to.tx(tx)
                        }
                    } else if(private$queue.bgd$len > 0) { # cdn queue is empty
                        tx <- private$number.of.tx.bytes(private$queue.bgd$len)                            
                        size <- private$queue.bgd$req[private$queue.bgd$len]
                        if(tx >= size) {
                            private$bgd.departure(size)
                            if(private$queue.bgd$len > 0) {
                                private$queue.bgd$update.bytes.pending.to.tx(size)
                            }
                            return(TRUE)
                        }
                        private$queue.cdn$update.bytes.pending.to.tx(tx)
                    } # cdn and bgd queues are empty
                    private$queue.last.update.time <- simu.currtime
                    return(FALSE)
                }
            ),
            ##
            public = list(
                initialize = function(
                    id, # Proxy id
                    zrr, # Zone RR
                    access.bw=1e6, # Internet access line Bw in Bps
                    zrr.update.time=1,
                    max.queue.len=1000) { # Maximum number of ongoing requests.
                    ##
                    private$id <- id
                    private$zrr <- zrr
                    private$zrr.update.time <- zrr.update.time
                    private$access.bw <- access.bw
                    private$dispatched <- 0
                    private$dispatched.lost <- 0
                    private$sum.successful.dispatched.bw <- access.bw
                    private$cdn.traffic.volume <- 0
                    private$updates <- 0
                    private$queue.last.update.time <- 0
                    ## set up the request queues
                    private$queue.cdn <- queue$new(max.len=max.queue.len) # queue of CDN requests
                    private$queue.bgd <- queue$new(max.len=max.queue.len) # queue of background requests
                    ##
                    private$cdn.throughput.sum <- 0
                    private$bgd.throughput.sum <- 0
                    ## Schedule the ZRR update instant.
                    super$sched.event(time=runif(1, max=zrr.update.time))
                },
                get.access.bw = function() { private$access.bw },
                ##
                ## handle cdn arrivals
                ##
                cdn.arrival = function(size) {
                    if(debug.events) {
                        message(sprintf("%.2f cdn.arr %d", simu.currtime, private$id))
                    }
                    private$cdn.traffic.volume <- private$cdn.traffic.volume + size
                    while(private$update.queue.req()){}
                    if(!private$queue.cdn$add(size)) { # the request is lost
                        private$dispatched.lost <- private$dispatched.lost+1
                    }
                },
                ##
                ## handle background arrivals
                ##
                bgd.arrival = function(size) {
                    if(debug.events) {
                        message(sprintf("%.2f bgd.arr %d", simu.currtime, private$id))
                    }
                    while(private$update.queue.req()){}
                    private$queue.bgd$add(size)
                },
                ##
                ## event handler: update ZRR
                ##
                handle.event = function() {
                    private$updates <- private$updates + 1
                    while(private$update.queue.req()){}
                    r <-
                        if(private$dispatched > 0) {
                            max(private$dispatched/private$sum.successful.dispatched.bw,
                                max(private$queue.cdn$len+private$queue.bgd$len,1)/private$access.bw)
                        } else {
                            max(private$queue.cdn$len+private$queue.bgd$len,1)/private$access.bw
                        }
                    if(debug.events) {
                        message(sprintf("%.2f proxy.send%d e=%d r=%.2g v=%.2f",
                                        simu.currtime, private$id,
                                        private$dispatched+private$dispatched.lost,
                                        r,
                                        v=private$cdn.traffic.volume))
                    }
                    send.message$new(delay=get.owd(),
                                     destination=private$zrr$update,
                                     parameters=list(id=private$id,
                                         r=r,
                                         e=private$dispatched+private$dispatched.lost,
                                         v=private$cdn.traffic.volume))
                    private$cdn.traffic.volume <- 0
                    private$dispatched <- 0
                    private$dispatched.lost <- 0
                    private$sum.successful.dispatched.bw <- 0
                    super$sched.event(time=private$zrr.update.time)
                },
                print.header = function() {
                    message("# Legend:\n",
                            "#  1: ProxyId\n",
                            "#  2: Bw [MBps]\n",
                            "#  3: updates\n",
                            "#  4: cdn.arrivals\n",
                            "#  5: cdn.lost\n",
                            "#  6: cdn.ongoing.req\n",
                            "#  7  bgd.arrivals\n",
                            "#  8: bgd.lost\n",
                            "#  9: bgd.ongoing.req\n",
                            "# 10: cdn.throughput [MBps]\n",
                            "# 11: bgd.throughput [MBps]")
                    message("#1", format(width=6,justify='right',paste0(2:11, coll='')))
                },
                print.queues = function() {
                    message('CDN')
                    private$queue.cdn$print()
                    message('BGD')
                    private$queue.bgd$print()
                },
                print = function() {
                    message(sprintf("%2d %5.2f %5d %5d %5d %5d %5d %5d %5d %5.2f %5.2f",
                                    private$id,
                                    private$access.bw*1e-6,
                                    private$updates,
                                    private$queue.cdn$arrivals,
                                    private$queue.cdn$lost,
                                    private$queue.cdn$len,
                                    private$queue.bgd$arrivals,
                                    private$queue.bgd$lost,
                                    private$queue.bgd$len,
                                    private$cdn.throughput.sum/(private$queue.cdn$departures*1e6),
                                    private$bgd.throughput.sum/(private$queue.bgd$departures*1e6)
                                    ))
                }
            ))
## End of Proxy class
